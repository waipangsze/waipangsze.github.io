---
layout: post
title: MPAS | LBC
categories: [MPAS]
tags: [WRF, MPAS, IC, LBC, NWP]
author: wpsze
date: 2025-03-14 10:33:00
math: true
mathjax: true
mathjax_autoNumber: true
mermaid: true
index_img: https://i.imgur.com/XAsb6tG.png
banner_img: https://i.imgur.com/XAsb6tG.png
---

# Links

1. [https://mpas-dev.github.io/](https://mpas-dev.github.io/)
2. [/MPAS-Model/releases](https://github.com/MPAS-Dev/MPAS-Model/releases)
3. [MPAS-Atmosphere Users' Guide V4.0](https://www2.mmm.ucar.edu/projects/mpas/mpas_atmosphere_users_guide_4.0.pdf)
4. [MPAS-Atmosphere Users' Guide V5.3](https://www2.mmm.ucar.edu/projects/mpas/mpas_atmosphere_users_guide_5.3.pdf)
5. [MPAS-Atmosphere Users' Guide V6.3](https://www2.mmm.ucar.edu/projects/mpas/mpas_atmosphere_users_guide_6.3.pdf)
6. [MPAS-Atmosphere Users' Guide V7.0](https://www2.mmm.ucar.edu/projects/mpas/mpas_atmosphere_users_guide_7.0.pdf)
7. [MPAS-Atmosphere Users' Guide V8.2.0](https://www2.mmm.ucar.edu/projects/mpas/mpas_atmosphere_users_guide_8.2.0.pdf)
8. [Joint WRF/MPAS Users Workshop 2024](https://www.mmm.ucar.edu/events/133129/agenda)

# References

- **MPAS-Atmosphere Version 7.0**, 8 June 2019
  - **The capability to perform limited-area simulations on the surface of the sphere.**
- [Running limited-area simulations | MPAS tutorial practice guide](https://www2.mmm.ucar.edu/projects/mpas/tutorial/Howard2024/index.html)
  - Having prepared a region definition file, we can use the **create_region** tool to create a subset of an existing global "`static`" file for our specified region.
  - The interpolation of lateral boundary conditions for a regional simulation domain is conceptually similar to the interpolation of initial conditions: the key differences are: 
    - (1) fields are **interpolated** at several time periods, and 
    - (2) the set of fields to be **interpolated** is a subset of those required for initial conditions (this subset includes: **theta, rho, u, w, and moisture species**). 

# Code

## mpas_stream_manager.F

- MPAS_stream_mgr_get_property

{% fold info @MPAS_stream_mgr_get_property %}
```fortran
    interface MPAS_stream_mgr_get_property
        module procedure MPAS_stream_mgr_get_property_int
        module procedure MPAS_stream_mgr_get_property_char
        module procedure MPAS_stream_mgr_get_property_logical
    end interface
    
    !-----------------------------------------------------------------------
    !  routine MPAS_stream_mgr_get_property_int
    !
    !> \brief Gets a property of a stream in an MPAS stream manager.
    !> \author Michael Duda, Doug Jacobsen
    !> \date   13 June 2014
    !> \details
    !>  Retrieves the value of a stream property within an MPAS stream manager.
    !>  NOTE: This routine does not support streamID regular expressions
    !
    !-----------------------------------------------------------------------
    subroutine MPAS_stream_mgr_get_property_int(manager, streamID, propertyName, propertyValue, direction, ierr)
```
{% endfold %}

## core_init_atmosphere

- `src/core_init_atmosphere/Registry.xml`
    {% fold info @src/core_init_atmosphere/Registry.xml %}
    ```xml
    <package name="lbcs" description="Active when lateral boundary conditions are interpolated and written.â€¦
    <stream name="lbc"
                    type="output"
                    filename_template="lbc.$Y-$M-$D_$h.$m.$s.nc"
                    output_interval="3:00:00"
                    packages="lbcs"
    <var_struct name="lbc_state"/>
    <var_struct name="lbc_state" time_levs="1">
            <var name="lbc_u" type="real" dimensions="nVertLevels nEdges Time" packages="lbcs"
            <var name="lbc_w" type="real" dimensions="nVertLevelsP1 nCells Time" packages="lbcs"
                    units="m s^{-1}"
            <var name="lbc_rho" type="real" dimensions="nVertLevels nCells Time" packages="lbcs"
            <var name="lbc_theta" type="real" dimensions="nVertLevels nCells Time" packages="lbcs"
            <var_array name="lbc_scalars" type="real" dimensions="nVertLevels nCells Time" packages="lbcs">
                    <var name="lbc_qv" array_group="moist" units="kg kg^{-1}"
                    <var name="lbc_qc" array_group="moist" units="kg kg^{-1}"
                    <var name="lbc_qr" array_group="moist" units="kg kg^{-1}"
                    <var name="lbc_nifa" array_group="number" units="nb kg^{-1}"
                    <var name="lbc_nwfa" array_group="number" units="nb kg^{-1}"
    ```
    {% endfold %}
- `/src/core_init_atmosphere/mpas_init_atm_core_interface.F`
    {% fold info @src/core_init_atmosphere/mpas_init_atm_core_interface.F %}
    ```fortran
    !
    ! When interpolating LBC fields, we need all inputs that would be needed for the interpolation
    ! of ICs, so met_stage_in = .true.
    !
    else if (config_init_case == 9) then
        gwd_stage_in = .false.
        gwd_stage_out = .false.
        vertical_stage_in = .false.
        vertical_stage_out = .false.
        met_stage_in = .true.
        met_stage_out = .true.

        mp_thompson_aers_in = .false.
        inquire(file="QNWFA_QNIFA_SIGMA_MONTHLY.dat",exist=lexist)
        if((lexist .and. met_stage_out) .or. (lexist .and. met_stage_in)) mp_thompson_aers_in = .true.

        initial_conds = .false.   ! Also, turn off the initial_conds package to avoid writing the IC "output" stream
    ```
    {% endfold %}
- `src/core_init_atmosphere/mpas_init_atm_cases.F`
    {% fold info @src/core_init_atmosphere/mpas_init_atm_cases.F %}
    ```fortran
       !-----------------------------------------------------------------------
   !  routine init_atm_case_lbc
   !
   !> \brief Computes lbc_{rho,theta,u,w,qx} fields for lateral boundary conditions
   !> \author Michael Duda
   !> \date   22 April 2019
   !> \details
   !>  This routine is similar to the init_atm_case_gfs routine in that it reads
   !>  atmospheric fields from "intermediate" files and horizontally and vertically
   !>  interpolates them to an MPAS mesh. However, rather than producing model
   !>  initial conditions, this routine is responsible for producing only those
   !>  fields that are needed as model lateral boundary conditions.
   !
   !-----------------------------------------------------------------------
   subroutine init_atm_case_lbc(timestamp, block, mesh, nCells, nEdges, nVertLevels, fg, state, diag, lbc_state, dims, configs)
   .....
   ```
   {% endfold %}

## core_atmosphere

- `src/core_atmosphere/dynamics/mpas_atm_boundaries.F`
    ```fortran
    !***********************************************************************
    !
    !  routine mpas_atm_update_bdy_tend
    !
    !> \brief   Reads new boundary data and updates the LBC tendencies
    !> \author  Michael Duda
    !> \date    27 September 2016
    !> \details 
    !>  This routine reads from the 'lbc_in' stream all variables in the 'lbc'
    !>  pool. When called with firstCall=.true., the latest time before the
    !>  present is read into time level 2 of the lbc pool; otherwise, the
    !>  contents of time level 2 are shifted to time level 1, the earliest
    !>  time strictly later than the present is read into time level 2, and
    !>  the tendencies for all fields in the lbc pool are computed and stored
    !>  in time level 1.
    !
    !-----------------------------------------------------------------------
    ......
    call mpas_set_time(currTime, dateTimeString=trim(read_time))
    ......
    !
    ! Compute any derived fields from those that were read from the lbc_in stream
    !
    call mpas_pool_get_array(lbc, 'lbc_u', u, 2)
    call mpas_pool_get_array(lbc, 'lbc_ru', ru, 2)
    call mpas_pool_get_array(lbc, 'lbc_rho_edge', rho_edge, 2)
    call mpas_pool_get_array(lbc, 'lbc_theta', theta, 2)
    call mpas_pool_get_array(lbc, 'lbc_rtheta_m', rtheta_m, 2)
    call mpas_pool_get_array(lbc, 'lbc_rho_zz', rho_zz, 2)
    call mpas_pool_get_array(lbc, 'lbc_rho', rho, 2)
    call mpas_pool_get_array(lbc, 'lbc_scalars', scalars, 2)
    ......
    if (.not. firstCall) then
        lbc_interval = currTime - LBC_intv_end
        call mpas_get_timeInterval(interval=lbc_interval, DD=dd_intv, S=s_intv, S_n=sn_intv, S_d=sd_intv, ierr=ierr)
        dt = 86400.0_RKIND * real(dd_intv, kind=RKIND) + real(s_intv, kind=RKIND) &
                + (real(sn_intv, kind=RKIND) / real(sd_intv, kind=RKIND))
        ......  
        call mpas_pool_get_array(lbc, 'lbc_u', u, 2)
        call mpas_pool_get_array(lbc, 'lbc_u', lbc_tend_u, 1)
        dt = 1.0_RKIND / dt
        lbc_tend_u(:,:) = (u(:,:) - lbc_tend_u(:,:)) * dt
        !
        ! Logging the lbc start and end times appears to be backwards, but
        ! until the end of this function, LBC_intv_end == the last interval
        ! time and currTime == the next interval time.
        !
        .......
    ```

{% note primary %}
`lbc_tend_u(:,:) = (u(:,:) - lbc_tend_u(:,:)) * dt` ==> has shown the linear interpolation between two time LBCs intervals.
{% endnote %}

#### src/framework/mpas_pool_routines.F

##### mpas_pool_get_array

- mpas_pool_get_array(inPool, key, scalar, timeLevel)
  - mpas_pool_get_field_0d_real(inPool, key, field, timeLevel)
    - mem => pool_get_member(inPool, key, MPAS_POOL_FIELD)
    - field => mem % r0 if mem % contentsTimeLevs == 1
    - field => mem % r0a(local_timeLevel) mem % contentsTimeLevs != 1
      - In Fortran, when dealing with classes (specifically in the context of object-oriented programming introduced in Fortran 2003), the `%` operator is used to access components (like variables or methods) of a derived type (which is similar to a class in other programming languages).

{% fold info @mpas_pool_get_array %}
```fortran
interface mpas_pool_get_array
  module procedure mpas_pool_get_array_0d_real
  module procedure mpas_pool_get_array_1d_real
  module procedure mpas_pool_get_array_2d_real
  module procedure mpas_pool_get_array_3d_real
  module procedure mpas_pool_get_array_4d_real
  module procedure mpas_pool_get_array_5d_real
  module procedure mpas_pool_get_array_0d_int
  module procedure mpas_pool_get_array_1d_int
  module procedure mpas_pool_get_array_2d_int
  module procedure mpas_pool_get_array_3d_int
  module procedure mpas_pool_get_array_0d_char
  module procedure mpas_pool_get_array_1d_char
end interface

!-----------------------------------------------------------------------
!  subroutine mpas_pool_get_array_0d_real
!
!> \brief MPAS Pool 0D Real field get subroutine
!> \author Michael Duda, Doug Jacobsen
!> \date   03/27/2014
!> \details
!> This subroutine returns a pointer to the array associated with key in inPool.
!
!-----------------------------------------------------------------------
   subroutine mpas_pool_get_array_0d_real(inPool, key, scalar, timeLevel)

      implicit none

      type (mpas_pool_type), intent(in) :: inPool
      character (len=*), intent(in) :: key
      real (kind=RKIND), pointer :: scalar
      integer, intent(in), optional :: timeLevel

      type (field0DReal), pointer :: field


      call mpas_pool_get_field_0d_real(inPool, key, field, timeLevel)

      nullify(scalar)
      if (associated(field)) scalar => field % scalar

   end subroutine mpas_pool_get_array_0d_real
   
   
!-----------------------------------------------------------------------
!  subroutine mpas_pool_get_field_0d_real
!
!> \brief MPAS Pool 0D Real field get subroutine
!> \author Michael Duda, Doug Jacobsen
!> \date   03/27/2014
!> \details
!> This subroutine returns a pointer to the field associated with key in inPool.
!
!-----------------------------------------------------------------------
   subroutine mpas_pool_get_field_0d_real(inPool, key, field, timeLevel)

      implicit none

      type (mpas_pool_type), intent(in) :: inPool
      character (len=*), intent(in) :: key
      type (field0DReal), pointer :: field
      integer, intent(in), optional :: timeLevel

      type (mpas_pool_data_type), pointer :: mem
      integer :: local_timeLevel


      if (present(timeLevel)) then
         local_timeLevel = timeLevel
      else
         local_timeLevel = 1
      end if
      
      ......
      
      mem => pool_get_member(inPool, key, MPAS_POOL_FIELD)
      
         if (mem % contentsTimeLevs == 1) then
            field => mem % r0
         else
            field => mem % r0a(local_timeLevel)
         end if
```
{% endfold %}

# Prepared lbc.nc files

- [Running limited-area simulations | MPAS tutorial practice guide](https://www2.mmm.ucar.edu/projects/mpas/tutorial/Howard2024/index.html)
- Each `lbc.ttt.nc` contains LBC values at **T=ttt**.
